// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "UnityCG.cginc"

struct instancing_data
{
    float4x4 trs;
    float4 wind;
    float4 bend;
};

float4 _CameraPlanes[6];
float4x4 _CameraVPMatrix;         //camera vp matrix.
float4 _BoundPoints[8];
Texture2D _HizDepthTexture;

float _Wind;
float _WindGap;
float4 _WindDir;        //w=sqrt(AA+BB+CC)
Texture2D _WindNoise;

uint _RoleCount;
float4 _RoleInfos[8];

uint _InstanceCount;
StructuredBuffer<instancing_data> _InstancingBuffer;
AppendStructuredBuffer<instancing_data> _CullResult;

bool IsInClipSpace(float4 clip_pos)
{
    return clip_pos.x > -clip_pos.w && clip_pos.x < clip_pos.w
    && clip_pos.y > -clip_pos.w && clip_pos.y < clip_pos.w
    && clip_pos.z > 0 && clip_pos.z < clip_pos.w;
}

bool IsCulling(float4x4 trs)
{
    bool in_clip = false;
    float4x4 mvpMatrix = mul(_CameraVPMatrix, trs);
    float4 cps[8];
    for (int i = 0; i < 8; i++)
    {
        cps[i] = mul(mvpMatrix, _BoundPoints[i]);
        in_clip = in_clip || IsInClipSpace(cps[i]);
    }

    bool depth_culling = false;
    if (in_clip)
    {
        float3 min_p = float3(1, 1, 1);             //AABB for NDC
        float3 max_p = float3(-1, -1, -1);
        for (int i = 0; i < 8; i++)
        {
            float4 clip_pos = cps[i];
            float3 ndc = clip_pos.xyz / clip_pos.w;
            min_p = min(min_p, ndc);
            max_p = max(max_p, ndc);
        }

        //ncd[-1,1] to uv[0,1]
        float2 uv_center = (min_p + max_p).xy / 2 * 0.5f + 0.5f;

        //select mipmap level
        uint tex_size = 256;
        uint mipmap_level = (uint)clamp(log2(max(max_p.x - min_p.x, max_p.y - min_p.y) * tex_size) + 1, 0, 4);      //size[16,256]->mip[4,0]
        uint size = tex_size / (1 << mipmap_level);

        //compare depth value culling
        uint2 pixel_center = uint2(clamp(uv_center.x * size, 0, size - 1), clamp(uv_center.y * size, 0, size - 1));
        float depth_tex = _HizDepthTexture.mips[mipmap_level][pixel_center].r;
        depth_culling = max_p.z < depth_tex;      //The smaller the farther
    }
    return !in_clip || depth_culling;
}

fixed4 Tex2DWrap(Texture2D tex, uint2 size, float2 uv)
{
    uv = frac(1+frac(uv));      //set uv to 0-1
    float2 pos = uv * size;
    int2 start = int2(pos.x, pos.y);
    int2 end = int2((start.x+1)%size.x, (start.y+1)%size.y);
    float2 f = float2(frac(pos.x), frac(pos.y));
    float4 c_0 = tex[start];
    float4 c_1 = tex[int2(end.x, start.y)];
    float4 c_2 = tex[int2(start.x, end.y)];
    float4 c_3 = tex[end];
    float4 c_01 = lerp(c_0, c_1, f.x);
    float4 c_23 = lerp(c_2, c_3, f.x);
    return lerp(c_01, c_23, f.y);
}

float4 GetBend(float3 pos)
{
    float4 bend_dir = float4(0, 0, 0, 0);
    for (uint i=0; i<_RoleCount; ++i)
    {
        float4 ri = _RoleInfos[i];
        float3 dir = pos - ri.xyz;
        float bend_max = 1 * ri.w;
        float bend_min = 0.3 * ri.w;
        float bend_dis_2 = dot(dir,dir);
        if (bend_dis_2 < bend_max * bend_max)
        {
            float br = 1 - smoothstep(bend_min, bend_max, sqrt(bend_dis_2));
            bend_dir.xyz += normalize(dir) * br;
            bend_dir.w = max(bend_dir.w, br);
        }
    }
    if (bend_dir.w > 0)
    {
        bend_dir.xyz = normalize(bend_dir.xyz);
    }    
    return bend_dir;
}

[numthreads(512, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _InstanceCount)
    {
        return;
    }

    //view frushtum culling
    instancing_data data = _InstancingBuffer[id.x];
    if (IsCulling(data.trs))
    {
        return;
    }

    //compute wind
    float3 pos = data.trs._14_24_34;        //_14_24_34 = position
    float2 noise_uv = (-_WindDir.xz * _Wind + pos.xz) / _WindGap;       //UV move in the opposite direction
    float rate = Tex2DWrap(_WindNoise, uint2(256, 256), noise_uv).r * 1;
    data.wind.xyz = _WindDir.xyz + _WindDir.zyx * (rate - 0.5);         //swing
    data.wind.w = rate;

    //compute bend
    float4 bend = GetBend(pos);
    data.bend = bend;
    data.bend.w *= 1 - rate * 0.5;
    data.wind.w *= 1 - bend.w * 0.5;

    _CullResult.Append(data);
}
